#!/usr/bin/env bash
# bin/compile <build-dir> <cache-dir>

# This was a great aid to writing this script:
# https://github.com/heroku/heroku-buildpack-ci-postgresql/blob/master/bin/compile

# fail fast
set -e

# debug
#set -x

echo "-----> In bin/test-compile"

# parse and derive params
BUILD_DIR=$1
CACHE_DIR=$2
ENV_DIR=$3
BUILDPACK_DIR="$(dirname $(dirname $0))"

function error() {
  echo " !     $*" >&2
  exit 1
}

function indent() {
  c='s/^/       /'
  case $(uname) in
    Darwin) sed -l "$c";;
    *)      sed -u "$c";;
  esac
}


# The heroku ruby buildpack will have already installed the gems for the default Gemfile, so now
# install the missing gems from Gemfile_next. We want gem versions from both Gemfiles to be in the
# app for parity with the production slug.
echo "-----> Installing Gemfile_next gems"
cd $BUILD_DIR
BUNDLE_GEMFILE=Gemfile_next bundle install --without development --path vendor/bundle --binstubs vendor/bundle/bin -j4 --deployment | indent

echo "-----> Writing .profile.d/multiple-gemfiles.sh to run on dyno startup"
mkdir -p .profile.d
cat<<\EOF > .profile.d/multiple-gemfiles.sh
# if [ -n "$DEPENDENCIES_NEXT_DYNOS" ]; then
if [ -n "$DEPENDENCIES_NEXT_CI_NODES" ]; then
  # Split on comma into an array of dynos
  # TODO: Test on string without comma but single dyno name
  next_dynos=($(echo $DEPENDENCIES_NEXT_CI_NODES | tr "," " "))

  # if [ -n "$DYNO" ]; then
    # dyno=$DYNO
  # elif [ -n "$CI_NODE_INDEX" ]; then
    dyno=$CI_NODE_INDEX
  # fi

  echo "Preparing Gemfile for dyno: $dyno"

  for ((i=0; i<${#next_dynos[@]}; i++)); do
    if [[ ${next_dynos[$i]} == ${dyno} ]]; then
      echo "Shuffling Gemfiles to use Gemfile_next"
      export DEPENDENCIES_NEXT=1
      mv "$HOME/Gemfile" "$HOME/Gemfile_prev"
      mv "$HOME/Gemfile.lock" "$HOME/Gemfile_prev.lock"
      mv "$HOME/Gemfile_next" "$HOME/Gemfile"
      mv "$HOME/Gemfile_next.lock" "$HOME/Gemfile.lock"
    fi
  done
fi
EOF

echo "-----> Multiple Gemfiles done"
